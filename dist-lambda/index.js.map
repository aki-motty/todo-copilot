{"version":3,"file":"index.js","sources":["../src/infrastructure/config/logger.ts","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/native.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/domain/entities/Todo.ts","../src/shared/types.ts","../src/infrastructure/persistence/LocalStorageTodoRepository.ts","../src/application/services/TodoApplicationService.ts","../src/domain/events/TodoEvents.ts","../src/shared/api/types.ts","../src/infrastructure/lambda/handlers/index.ts","../src/index.lambda.ts"],"sourcesContent":["/**\n * Logger configuration for the application\n * Provides structured logging with consistent format\n */\n\ninterface LogEntry {\n  timestamp: string;\n  level: \"debug\" | \"info\" | \"warn\" | \"error\";\n  module?: string;\n  message: string;\n  data?: Record<string, unknown>;\n}\n\nclass Logger {\n  private logLevel: \"debug\" | \"info\" | \"warn\" | \"error\" = \"info\";\n\n  constructor(private moduleName?: string) {\n    // Only try to access import.meta in browser/vite environment\n    if (typeof window !== \"undefined\" && (window as any).import?.meta?.env?.VITE_LOG_LEVEL) {\n      this.logLevel = (window as any).import.meta.env.VITE_LOG_LEVEL;\n    }\n  }\n\n  private shouldLog(level: \"debug\" | \"info\" | \"warn\" | \"error\"): boolean {\n    const levels = [\"debug\", \"info\", \"warn\", \"error\"];\n    return levels.indexOf(level) >= levels.indexOf(this.logLevel);\n  }\n\n  private formatEntry(entry: LogEntry): string {\n    const { timestamp, level, module, message, data } = entry;\n    const moduleStr = module ? ` [${module}]` : \"\";\n    const dataStr = data ? ` ${JSON.stringify(data)}` : \"\";\n    return `${timestamp} ${level.toUpperCase()}${moduleStr}: ${message}${dataStr}`;\n  }\n\n  debug(message: string, data?: Record<string, unknown>): void {\n    if (this.shouldLog(\"debug\")) {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"debug\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.debug(this.formatEntry(entry));\n    }\n  }\n\n  info(message: string, data?: Record<string, unknown>): void {\n    if (this.shouldLog(\"info\")) {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"info\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.info(this.formatEntry(entry));\n    }\n  }\n\n  warn(message: string, data?: Record<string, unknown>): void {\n    if (this.shouldLog(\"warn\")) {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"warn\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.warn(this.formatEntry(entry));\n    }\n  }\n\n  error(message: string, error?: Error | Record<string, unknown>): void {\n    if (this.shouldLog(\"error\")) {\n      const data = error instanceof Error ? { message: error.message, stack: error.stack } : error;\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"error\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.error(this.formatEntry(entry));\n    }\n  }\n}\n\nexport const createLogger = (moduleName?: string): Logger => {\n  return new Logger(moduleName);\n};\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Branded type for unique Todo identifiers\n * Ensures type safety at compile time while maintaining string at runtime\n */\nexport type TodoId = string & { readonly __brand: \"TodoId\" };\n\nconst brandTodoId = (id: string): TodoId => id as TodoId;\n\n/**\n * Value object for Todo title\n * Enforces invariants: 1-500 characters, non-empty\n */\nexport class TodoTitle {\n  private constructor(private readonly _value: string) {\n    if (!_value || _value.trim().length === 0) {\n      throw new Error(\"Todo title cannot be empty\");\n    }\n    if (_value.length > 500) {\n      throw new Error(\"Todo title cannot exceed 500 characters\");\n    }\n  }\n\n  static create(value: string): TodoTitle {\n    return new TodoTitle(value.trim());\n  }\n\n  get value(): string {\n    return this._value;\n  }\n\n  equals(other: TodoTitle): boolean {\n    return this._value === other._value;\n  }\n\n  toString(): string {\n    return this._value;\n  }\n}\n\n/**\n * Value object for Todo status\n * Represents the completion state of a todo\n */\nexport type TodoStatus = \"Pending\" | \"Completed\";\n\n/**\n * Todo aggregate root\n * Core entity representing a todo item with immutable state\n */\nexport class Todo {\n  private constructor(\n    private readonly _id: TodoId,\n    private readonly _title: TodoTitle,\n    private readonly _completed: boolean,\n    private readonly _createdAt: Date,\n    private readonly _updatedAt: Date\n  ) {}\n\n  /**\n   * Factory method to create a new Todo\n   * Generates a new UUID and sets creation timestamp\n   */\n  static create(title: string): Todo {\n    const id = brandTodoId(uuidv4());\n    const todoTitle = TodoTitle.create(title);\n    const now = new Date();\n\n    return new Todo(id, todoTitle, false, now, now);\n  }\n\n  /**\n   * Recreate Todo from persistence layer\n   * Used when loading from localStorage\n   */\n  static fromPersistence(\n    id: string,\n    title: string,\n    completed: boolean,\n    createdAt: string,\n    updatedAt: string\n  ): Todo {\n    const todoId = brandTodoId(id);\n    const todoTitle = TodoTitle.create(title);\n    return new Todo(todoId, todoTitle, completed, new Date(createdAt), new Date(updatedAt));\n  }\n\n  /**\n   * Create a new Todo with toggled completion status\n   * Maintains immutability by returning a new instance\n   */\n  toggleCompletion(): Todo {\n    return new Todo(\n      this._id,\n      this._title,\n      !this._completed,\n      this._createdAt,\n      new Date() // Update timestamp\n    );\n  }\n\n  // Getters (read-only access to private fields)\n\n  get id(): TodoId {\n    return this._id;\n  }\n\n  get title(): TodoTitle {\n    return this._title;\n  }\n\n  get completed(): boolean {\n    return this._completed;\n  }\n\n  get status(): TodoStatus {\n    return this._completed ? \"Completed\" : \"Pending\";\n  }\n\n  get createdAt(): Date {\n    return new Date(this._createdAt); // Return copy to prevent external mutation\n  }\n\n  get updatedAt(): Date {\n    return new Date(this._updatedAt); // Return copy to prevent external mutation\n  }\n\n  /**\n   * Convert to plain object for serialization (e.g., to localStorage)\n   */\n  toJSON() {\n    return {\n      id: this._id,\n      title: this._title.value,\n      completed: this._completed,\n      createdAt: this._createdAt.toISOString(),\n      updatedAt: this._updatedAt.toISOString(),\n    };\n  }\n\n  /**\n   * Compare two Todo instances\n   */\n  equals(other: Todo): boolean {\n    return this._id === other._id && this._completed === other._completed;\n  }\n}\n","/**\n * Shared type definitions for todo-copilot application\n * Used across all layers of the application\n */\n\n/**\n * Branded type for unique identifiers\n * Provides type-level distinction while maintaining string runtime behavior\n */\nexport type Branded<T, Brand> = T & { readonly __brand: Brand };\n\n/**\n * Factory for branded types\n */\nexport const brand = <T, B>(value: T): Branded<T, B> => value as Branded<T, B>;\n\n/**\n * Application error types\n */\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nexport class NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n}\n\nexport class QuotaExceededError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"QuotaExceededError\";\n  }\n}\n\nexport class StorageCorruptionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"StorageCorruptionError\";\n  }\n}\n\n/**\n * Base result type for operations\n */\nexport type Result<T, E = Error> = { type: \"success\"; value: T } | { type: \"error\"; error: E };\n\nexport const success = <T>(value: T): Result<T> => ({ type: \"success\", value });\nexport const failure = <E extends Error>(error: E): Result<never, E> => ({\n  type: \"error\",\n  error,\n});\n\n/**\n * Async result type\n */\nexport type AsyncResult<T, E = Error> = Promise<Result<T, E>>;\n","import { Todo, type TodoId } from \"../../domain/entities/Todo\";\nimport type { ITodoRepository } from \"../../domain/repositories/TodoRepository\";\nimport { NotFoundError, QuotaExceededError, StorageCorruptionError } from \"../../shared/types\";\n\n/**\n * LocalStorage implementation of TodoRepository\n * Persists todos to browser's localStorage\n *\n * Storage schema:\n * Key: \"todo_app:todos\"\n * Value: JSON array of serialized todos\n */\nexport class LocalStorageTodoRepository implements ITodoRepository {\n  private readonly storageKey = \"todo_app:todos\";\n  private readonly storagePrefix = \"todo_app:version\";\n  private readonly version = 1;\n\n  constructor(private readonly storage: Storage = window.localStorage) {\n    this.initializeStorage();\n  }\n\n  /**\n   * Initialize storage and verify integrity\n   */\n  private initializeStorage(): void {\n    try {\n      const versionKey = `${this.storagePrefix}`;\n      const storedVersion = this.storage.getItem(versionKey);\n\n      if (!storedVersion) {\n        this.storage.setItem(versionKey, this.version.toString());\n      } else if (Number.parseInt(storedVersion, 10) !== this.version) {\n        // Version mismatch - could implement migration logic here\n        console.warn(\"Storage version mismatch, resetting todos\");\n        this.clear();\n      }\n\n      // Try to parse existing todos to verify integrity\n      const data = this.storage.getItem(this.storageKey);\n      if (data) {\n        JSON.parse(data);\n      }\n    } catch (error) {\n      throw new StorageCorruptionError(\n        `Failed to initialize storage: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  findById(id: TodoId): Todo | null {\n    const todos = this.getAllFromStorage();\n    const todoData = todos.find((t) => t.id === id);\n    return todoData\n      ? Todo.fromPersistence(\n          todoData.id,\n          todoData.title,\n          todoData.completed,\n          todoData.createdAt,\n          todoData.updatedAt\n        )\n      : null;\n  }\n\n  findAll(): Todo[] {\n    const todos = this.getAllFromStorage();\n    return todos.map((t) =>\n      Todo.fromPersistence(t.id, t.title, t.completed, t.createdAt, t.updatedAt)\n    );\n  }\n\n  save(todo: Todo): void {\n    try {\n      const todos = this.getAllFromStorage();\n      const existingIndex = todos.findIndex((t) => t.id === todo.id);\n\n      if (existingIndex >= 0) {\n        todos[existingIndex] = todo.toJSON();\n      } else {\n        todos.push(todo.toJSON());\n      }\n\n      this.storage.setItem(this.storageKey, JSON.stringify(todos));\n    } catch (error) {\n      if (error instanceof DOMException && error.code === 22) {\n        throw new QuotaExceededError(\"localStorage quota exceeded. Please delete some todos.\");\n      }\n      throw error;\n    }\n  }\n\n  remove(id: TodoId): void {\n    const todos = this.getAllFromStorage();\n    const initialLength = todos.length;\n    const filtered = todos.filter((t) => t.id !== id);\n\n    if (filtered.length === initialLength) {\n      throw new NotFoundError(`Todo with id ${id} not found`);\n    }\n\n    this.storage.setItem(this.storageKey, JSON.stringify(filtered));\n  }\n\n  clear(): void {\n    this.storage.removeItem(this.storageKey);\n  }\n\n  count(): number {\n    return this.getAllFromStorage().length;\n  }\n\n  /**\n   * Get all todos from storage\n   * @private\n   */\n  private getAllFromStorage(): Array<{\n    id: string;\n    title: string;\n    completed: boolean;\n    createdAt: string;\n    updatedAt: string;\n  }> {\n    try {\n      const data = this.storage.getItem(this.storageKey);\n      if (!data) {\n        return [];\n      }\n      return JSON.parse(data);\n    } catch (error) {\n      throw new StorageCorruptionError(\n        `Failed to parse todos from storage: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n","import { Todo, type TodoId } from \"../../domain/entities/Todo\";\nimport {\n    createTodoCompletedEvent,\n    createTodoCreatedEvent,\n    createTodoDeletedEvent,\n    type DomainEvent,\n} from \"../../domain/events/TodoEvents\";\nimport type { ITodoRepository } from \"../../domain/repositories/TodoRepository\";\nimport { createLogger } from \"../../infrastructure/config/logger\";\nimport { NotFoundError } from \"../../shared/types\";\nimport type {\n    CreateTodoCommand,\n    DeleteTodoCommand,\n    ToggleTodoCompletionCommand,\n} from \"../commands\";\nimport type { GetAllTodosQuery, GetAllTodosResponse, GetTodoByIdQuery } from \"../queries\";\n\n/**\n * Application service for Todo use cases\n * Orchestrates domain entities and repository interactions\n * Implements CQRS pattern with separate command and query methods\n */\nexport class TodoApplicationService {\n  private logger = createLogger(\"TodoApplicationService\");\n  private domainEvents: DomainEvent[] = [];\n\n  constructor(private todoRepository: ITodoRepository) {}\n\n  /**\n   * Create a new todo\n   * COMMAND: Changes application state\n   */\n  createTodo(command: CreateTodoCommand): Todo {\n    this.logger.debug(\"Creating todo\", { title: command.title });\n\n    const todo = Todo.create(command.title);\n    this.todoRepository.save(todo);\n\n    // Publish domain event\n    const event = createTodoCreatedEvent(todo.id, command.title, todo.createdAt);\n    this.domainEvents.push(event);\n    this.logger.info(\"Todo created\", { id: todo.id, title: command.title });\n\n    return todo;\n  }\n\n  /**\n   * Toggle todo completion status\n   * COMMAND: Changes application state\n   */\n  toggleTodoCompletion(command: ToggleTodoCompletionCommand): Todo {\n    this.logger.debug(\"Toggling todo completion\", { id: command.id });\n\n    const todo = this.todoRepository.findById(command.id as TodoId);\n    if (!todo) {\n      throw new NotFoundError(`Todo with id ${command.id} not found`);\n    }\n\n    const updatedTodo = todo.toggleCompletion();\n    this.todoRepository.save(updatedTodo);\n\n    // Publish domain event\n    const event = createTodoCompletedEvent(\n      updatedTodo.id,\n      updatedTodo.status,\n      updatedTodo.updatedAt\n    );\n    this.domainEvents.push(event);\n    this.logger.info(\"Todo toggled\", {\n      id: updatedTodo.id,\n      status: updatedTodo.status,\n    });\n\n    return updatedTodo;\n  }\n\n  /**\n   * Delete a todo\n   * COMMAND: Changes application state\n   */\n  deleteTodo(command: DeleteTodoCommand): void {\n    this.logger.debug(\"Deleting todo\", { id: command.id });\n\n    const todo = this.todoRepository.findById(command.id as TodoId);\n    if (!todo) {\n      throw new NotFoundError(`Todo with id ${command.id} not found`);\n    }\n\n    this.todoRepository.remove(command.id as TodoId);\n\n    // Publish domain event\n    const event = createTodoDeletedEvent(todo.id, new Date());\n    this.domainEvents.push(event);\n    this.logger.info(\"Todo deleted\", { id: command.id });\n  }\n\n  /**\n   * Get all todos\n   * QUERY: Read-only operation\n   */\n  getAllTodos(_query: GetAllTodosQuery): GetAllTodosResponse {\n    this.logger.debug(\"Fetching all todos\");\n    const todos = this.todoRepository.findAll();\n    this.logger.info(\"Retrieved todos\", { count: todos.length });\n    return {\n      todos,\n      count: todos.length,\n    };\n  }\n\n  /**\n   * Get a single todo by ID\n   * QUERY: Read-only operation\n   */\n  getTodoById(query: GetTodoByIdQuery): Todo | null {\n    this.logger.debug(\"Fetching todo\", { id: query.id });\n    const todo = this.todoRepository.findById(query.id as TodoId);\n    if (todo) {\n      this.logger.debug(\"Todo found\", { id: query.id });\n    } else {\n      this.logger.debug(\"Todo not found\", { id: query.id });\n    }\n    return todo;\n  }\n\n  /**\n   * Get domain events that occurred since last call\n   * Used for event sourcing and audit trails\n   */\n  getDomainEvents(): DomainEvent[] {\n    const events = [...this.domainEvents];\n    this.domainEvents = [];\n    return events;\n  }\n}\n","import type { TodoId, TodoStatus } from \"../entities/Todo\";\n\n/**\n * Domain events for Todo aggregate\n * Used for event sourcing and audit trails\n */\n\nexport interface DomainEvent {\n  aggregateId: TodoId;\n  aggregateType: \"Todo\";\n  eventType: string;\n  timestamp: Date;\n  data: Record<string, unknown>;\n}\n\n/**\n * Event fired when a new Todo is created\n */\nexport interface TodoCreatedEvent extends DomainEvent {\n  eventType: \"TodoCreated\";\n  data: {\n    title: string;\n    createdAt: string;\n  };\n}\n\nexport const createTodoCreatedEvent = (\n  id: TodoId,\n  title: string,\n  createdAt: Date\n): TodoCreatedEvent => ({\n  aggregateId: id,\n  aggregateType: \"Todo\",\n  eventType: \"TodoCreated\",\n  timestamp: new Date(),\n  data: {\n    title,\n    createdAt: createdAt.toISOString(),\n  },\n});\n\n/**\n * Event fired when a Todo's completion status changes\n */\nexport interface TodoCompletedEvent extends DomainEvent {\n  eventType: \"TodoCompleted\" | \"TodoUncompleted\";\n  data: {\n    status: TodoStatus;\n    changedAt: string;\n  };\n}\n\nexport const createTodoCompletedEvent = (\n  id: TodoId,\n  status: TodoStatus,\n  changedAt: Date\n): TodoCompletedEvent => ({\n  aggregateId: id,\n  aggregateType: \"Todo\",\n  eventType: status === \"Completed\" ? \"TodoCompleted\" : \"TodoUncompleted\",\n  timestamp: new Date(),\n  data: {\n    status,\n    changedAt: changedAt.toISOString(),\n  },\n});\n\n/**\n * Event fired when a Todo is deleted\n */\nexport interface TodoDeletedEvent extends DomainEvent {\n  eventType: \"TodoDeleted\";\n  data: {\n    deletedAt: string;\n  };\n}\n\nexport const createTodoDeletedEvent = (id: TodoId, deletedAt: Date): TodoDeletedEvent => ({\n  aggregateId: id,\n  aggregateType: \"Todo\",\n  eventType: \"TodoDeleted\",\n  timestamp: new Date(),\n  data: {\n    deletedAt: deletedAt.toISOString(),\n  },\n});\n","/**\n * Shared types for Lambda API integration\n * Defines DTOs and response formats for the REST API\n */\n\nimport type { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from \"aws-lambda\";\n\n/**\n * Unified API response format for all Lambda endpoints\n * Ensures consistent response structure across all operations\n */\nexport interface ApiResponse<T = unknown> {\n  statusCode: number;\n  body: {\n    success: boolean;\n    data?: T;\n    error?: string;\n    message?: string;\n  };\n}\n\n/**\n * Todo data transfer object for API responses\n * Minimal serializable representation of Todo domain entity\n */\nexport interface TodoDTO {\n  id: string;\n  title: string;\n  completed: boolean;\n  createdAt: string; // ISO 8601 timestamp\n  updatedAt: string; // ISO 8601 timestamp\n}\n\n/**\n * Paginated list response for get todos endpoint\n */\nexport interface TodoListResponse {\n  items: TodoDTO[];\n  total: number;\n  page: number;\n  pageSize: number;\n  hasMore: boolean;\n}\n\n/**\n * Create todo request payload\n */\nexport interface CreateTodoRequest {\n  title: string;\n}\n\n/**\n * Update todo request payload\n */\nexport interface UpdateTodoRequest {\n  completed?: boolean;\n}\n\n/**\n * Lambda handler event type (alias for clarity)\n */\nexport type LambdaEvent = APIGatewayProxyEventV2;\n\n/**\n * Lambda handler context type\n */\nexport type LambdaContext = {\n  functionName: string;\n  functionVersion: string;\n  invokedFunctionArn: string;\n  memoryLimitInMB: string;\n  awsRequestId: string;\n  logGroupName: string;\n  logStreamName: string;\n  callbackWaitsForEmptyEventLoop?: boolean;\n};\n\n/**\n * Lambda handler return type\n */\nexport type LambdaResponse = APIGatewayProxyResultV2;\n\n/**\n * Utility function to extract path parameters from Lambda event\n */\nexport function getPathParameter(event: LambdaEvent, paramName: string): string | undefined {\n  return event.pathParameters?.[paramName];\n}\n\n/**\n * Utility function to extract query parameters from Lambda event\n */\nexport function getQueryParameter(event: LambdaEvent, paramName: string): string | undefined {\n  return event.queryStringParameters?.[paramName];\n}\n\n/**\n * Utility function to parse request body\n */\nexport function parseBody<T>(body: string | undefined): T {\n  if (!body) {\n    throw new Error(\"Request body is required\");\n  }\n  try {\n    return JSON.parse(body) as T;\n  } catch (error) {\n    throw new Error(`Failed to parse request body: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Create a successful API response\n */\nexport function createSuccessResponse<T>(statusCode: number, data: T): ApiResponse<T> {\n  return {\n    statusCode,\n    body: {\n      success: true,\n      data,\n    },\n  };\n}\n\n/**\n * Create an error API response\n */\nexport function createErrorResponse(statusCode: number, error: string, message?: string): ApiResponse {\n  return {\n    statusCode,\n    body: {\n      success: false,\n      error,\n      message,\n    },\n  };\n}\n","/**\n * Lambda handler for todo operations\n * Main entry point for AWS Lambda function handling HTTP requests from API Gateway\n */\n\nimport { createLogger } from \"../../../infrastructure/config/logger\";\nimport type { ITodoRepository } from \"../../../domain/repositories/TodoRepository\";\nimport { LocalStorageTodoRepository } from \"../../../infrastructure/persistence/LocalStorageTodoRepository\";\nimport { TodoApplicationService } from \"../../../application/services/TodoApplicationService\";\nimport type { LambdaContext, LambdaEvent, LambdaResponse } from \"../../../shared/api/types\";\nimport {\n  createSuccessResponse,\n  createErrorResponse,\n  getPathParameter,\n  parseBody,\n  getQueryParameter,\n} from \"../../../shared/api/types\";\nimport type { CreateTodoRequest, UpdateTodoRequest, TodoDTO } from \"../../../shared/api/types\";\nimport type { CreateTodoCommand } from \"../../../application/commands/CreateTodoCommand\";\nimport type { ToggleTodoCompletionCommand } from \"../../../application/commands/ToggleTodoCompletionCommand\";\nimport type { DeleteTodoCommand } from \"../../../application/commands/DeleteTodoCommand\";\nimport type { TodoId } from \"../../../domain/entities/Todo\";\n\nconst logger = createLogger(\"LambdaHandler\");\nlet todoRepository: ITodoRepository;\nlet applicationService: TodoApplicationService;\n\n/**\n * Initialize repository and application service\n * Called once per Lambda container (cold start)\n */\nfunction initializeHandlers(): void {\n  if (!todoRepository) {\n    todoRepository = new LocalStorageTodoRepository();\n    applicationService = new TodoApplicationService(todoRepository);\n  }\n}\n\n/**\n * Convert Todo domain entity to DTO for JSON response\n */\nfunction todoToDTO(todo: any): TodoDTO {\n  return {\n    id: todo.id,\n    title: todo.title.value || todo.title,\n    completed: todo.completed,\n    createdAt: todo.createdAt.toISOString?.() || todo.createdAt,\n    updatedAt: todo.updatedAt.toISOString?.() || todo.updatedAt,\n  };\n}\n\n/**\n * Handle GET /todos - Retrieve all todos\n */\nasync function handleGetTodos(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const page = parseInt(getQueryParameter(event, \"page\") || \"1\", 10);\n    const pageSize = parseInt(getQueryParameter(event, \"pageSize\") || \"50\", 10);\n\n    const result = applicationService.getAllTodos({});\n    const todos = result.todos;\n    const total = todos.length;\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedTodos = todos.slice(startIndex, endIndex);\n\n    const response = createSuccessResponse(200, {\n      items: paginatedTodos.map(todoToDTO),\n      total,\n      page,\n      pageSize,\n      hasMore: endIndex < total,\n    });\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error fetching todos\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle GET /todos/{id} - Retrieve a specific todo\n */\nasync function handleGetTodoById(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const id = getPathParameter(event, \"id\");\n    if (!id) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Todo ID is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const todo = applicationService.getTodoById({ id: id as any as TodoId });\n    if (!todo) {\n      const response = createErrorResponse(404, \"Not Found\", `Todo with ID ${id} not found`);\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = createSuccessResponse(200, todoToDTO(todo));\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error fetching todo\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle POST /todos - Create a new todo\n */\nasync function handleCreateTodo(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const payload = parseBody<CreateTodoRequest>(event.body);\n\n    if (!payload.title || payload.title.trim().length === 0) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Title is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    if (payload.title.length > 500) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Title cannot exceed 500 characters\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const command: CreateTodoCommand = {\n      title: payload.title,\n    };\n\n    const todo = applicationService.createTodo(command);\n    const response = createSuccessResponse(201, todoToDTO(todo));\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error creating todo\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle PUT /todos/{id} - Update a todo\n */\nasync function handleUpdateTodo(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const id = getPathParameter(event, \"id\");\n    if (!id) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Todo ID is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const payload = parseBody<UpdateTodoRequest>(event.body);\n\n    if (payload.completed === undefined) {\n      const response = createErrorResponse(400, \"Bad Request\", \"completed field is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const command: ToggleTodoCompletionCommand = {\n      id: id as any as TodoId,\n    };\n\n    const todo = applicationService.toggleTodoCompletion(command);\n    const response = createSuccessResponse(200, todoToDTO(todo));\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error updating todo\", error as any);\n\n    if (error instanceof Error && error.message.includes(\"not found\")) {\n      const response = createErrorResponse(404, \"Not Found\", \"Todo not found\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle DELETE /todos/{id} - Delete a todo\n */\nasync function handleDeleteTodo(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const id = getPathParameter(event, \"id\");\n    if (!id) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Todo ID is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const command: DeleteTodoCommand = {\n      id: id as any as TodoId,\n    };\n\n    applicationService.deleteTodo(command);\n    const response = createSuccessResponse(204, null);\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify({ success: true }),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error deleting todo\", error as any);\n\n    if (error instanceof Error && error.message.includes(\"not found\")) {\n      const response = createErrorResponse(404, \"Not Found\", \"Todo not found\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Main Lambda handler\n * Routes requests to appropriate handlers based on HTTP method and path\n */\nexport async function handler(event: LambdaEvent, context: LambdaContext): Promise<LambdaResponse> {\n  logger.info(\"Received Lambda event\", {\n    method: event.requestContext.http.method,\n    path: event.requestContext.http.path,\n    requestId: context.awsRequestId,\n  });\n\n  try {\n    initializeHandlers();\n\n    const method = event.requestContext.http.method;\n    const path = event.requestContext.http.path;\n\n    // Route requests to appropriate handlers\n    if (method === \"GET\" && path === \"/todos\") {\n      return await handleGetTodos(event);\n    }\n\n    if (method === \"GET\" && path.startsWith(\"/todos/\")) {\n      return await handleGetTodoById(event);\n    }\n\n    if (method === \"POST\" && path === \"/todos\") {\n      return await handleCreateTodo(event);\n    }\n\n    if (method === \"PUT\" && path.startsWith(\"/todos/\")) {\n      return await handleUpdateTodo(event);\n    }\n\n    if (method === \"DELETE\" && path.startsWith(\"/todos/\")) {\n      return await handleDeleteTodo(event);\n    }\n\n    // 404 for unknown routes\n    const response = createErrorResponse(404, \"Not Found\", \"Endpoint not found\");\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Unhandled error in Lambda handler\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n","/**\n * Lambda Entry Point\n * Main entry point for AWS Lambda function\n * Exports the handler function for use with AWS Lambda runtime\n * Can be bundled and deployed as Lambda function code\n */\n\nimport { handler } from \"./infrastructure/lambda/handlers/index\";\n\n/**\n * Export the Lambda handler\n * This function processes API Gateway events and returns formatted HTTP responses\n *\n * Usage:\n * - Deploy this file as Lambda function code\n * - Configure API Gateway to route requests to this function\n * - Handler name in Lambda console: index.handler\n */\nexport { handler };\n\n/**\n * For development/testing purposes, ensure the handler can be invoked directly\n */\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = { handler };\n}\n"],"names":["Logger","constructor","moduleName","this","window","import","meta","env","VITE_LOG_LEVEL","logLevel","shouldLog","level","levels","indexOf","formatEntry","entry","timestamp","module","message","data","moduleStr","dataStr","JSON","stringify","toUpperCase","debug","Date","toISOString","console","info","warn","error","Error","stack","createLogger","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","TodoTitle","_value","trim","length","create","value","equals","other","Todo","_id","_title","_completed","_createdAt","_updatedAt","title","id","uuidv4","todoTitle","now","fromPersistence","completed","createdAt","updatedAt","todoId","toggleCompletion","status","toJSON","NotFoundError","super","name","QuotaExceededError","StorageCorruptionError","LocalStorageTodoRepository","storage","localStorage","initializeStorage","storageKey","storagePrefix","version","versionKey","storedVersion","getItem","Number","parseInt","clear","setItem","parse","String","findById","todoData","getAllFromStorage","find","t","findAll","map","save","todo","todos","existingIndex","findIndex","DOMException","code","remove","initialLength","filtered","filter","removeItem","count","TodoApplicationService","todoRepository","logger","domainEvents","createTodo","command","event","aggregateId","aggregateType","eventType","toggleTodoCompletion","updatedTodo","changedAt","deleteTodo","deletedAt","getAllTodos","_query","getTodoById","query","getDomainEvents","events","getPathParameter","paramName","pathParameters","getQueryParameter","queryStringParameters","parseBody","body","createSuccessResponse","statusCode","success","createErrorResponse","applicationService","todoToDTO","async","handler","context","method","requestContext","http","path","requestId","awsRequestId","page","pageSize","total","startIndex","endIndex","response","items","hasMore","headers","handleGetTodos","startsWith","handleGetTodoById","payload","handleCreateTodo","includes","handleUpdateTodo","handleDeleteTodo","exports"],"mappings":"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","x_google_ignoreList":[1,2,3,4]}