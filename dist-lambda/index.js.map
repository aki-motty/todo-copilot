{"version":3,"file":"index.js","sources":["../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/native.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/domain/entities/Todo.ts","../src/infrastructure/config/logger.ts","../src/shared/types.ts","../src/application/services/TodoApplicationService.ts","../src/domain/events/TodoEvents.ts","../src/infrastructure/persistence/LocalStorageTodoRepository.ts","../src/shared/api/types.ts","../src/infrastructure/lambda/handlers/index.ts","../src/index.lambda.ts"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Branded type for unique Todo identifiers\n * Ensures type safety at compile time while maintaining string at runtime\n */\nexport type TodoId = string & { readonly __brand: \"TodoId\" };\n\nconst brandTodoId = (id: string): TodoId => id as TodoId;\n\n/**\n * Value object for Todo title\n * Enforces invariants: 1-500 characters, non-empty\n */\nexport class TodoTitle {\n  private constructor(private readonly _value: string) {\n    if (!_value || _value.trim().length === 0) {\n      throw new Error(\"Todo title cannot be empty\");\n    }\n    if (_value.length > 500) {\n      throw new Error(\"Todo title cannot exceed 500 characters\");\n    }\n  }\n\n  static create(value: string): TodoTitle {\n    return new TodoTitle(value.trim());\n  }\n\n  get value(): string {\n    return this._value;\n  }\n\n  equals(other: TodoTitle): boolean {\n    return this._value === other._value;\n  }\n\n  toString(): string {\n    return this._value;\n  }\n}\n\n/**\n * Value object for Todo status\n * Represents the completion state of a todo\n */\nexport type TodoStatus = \"Pending\" | \"Completed\";\n\n/**\n * Todo aggregate root\n * Core entity representing a todo item with immutable state\n */\nexport class Todo {\n  private constructor(\n    private readonly _id: TodoId,\n    private readonly _title: TodoTitle,\n    private readonly _completed: boolean,\n    private readonly _createdAt: Date,\n    private readonly _updatedAt: Date\n  ) {}\n\n  /**\n   * Factory method to create a new Todo\n   * Generates a new UUID and sets creation timestamp\n   */\n  static create(title: string): Todo {\n    const id = brandTodoId(uuidv4());\n    const todoTitle = TodoTitle.create(title);\n    const now = new Date();\n\n    return new Todo(id, todoTitle, false, now, now);\n  }\n\n  /**\n   * Recreate Todo from persistence layer\n   * Used when loading from localStorage\n   */\n  static fromPersistence(\n    id: string,\n    title: string,\n    completed: boolean,\n    createdAt: string,\n    updatedAt: string\n  ): Todo {\n    const todoId = brandTodoId(id);\n    const todoTitle = TodoTitle.create(title);\n    return new Todo(todoId, todoTitle, completed, new Date(createdAt), new Date(updatedAt));\n  }\n\n  /**\n   * Create a new Todo with toggled completion status\n   * Maintains immutability by returning a new instance\n   */\n  toggleCompletion(): Todo {\n    return new Todo(\n      this._id,\n      this._title,\n      !this._completed,\n      this._createdAt,\n      new Date() // Update timestamp\n    );\n  }\n\n  // Getters (read-only access to private fields)\n\n  get id(): TodoId {\n    return this._id;\n  }\n\n  get title(): TodoTitle {\n    return this._title;\n  }\n\n  get completed(): boolean {\n    return this._completed;\n  }\n\n  get status(): TodoStatus {\n    return this._completed ? \"Completed\" : \"Pending\";\n  }\n\n  get createdAt(): Date {\n    return new Date(this._createdAt); // Return copy to prevent external mutation\n  }\n\n  get updatedAt(): Date {\n    return new Date(this._updatedAt); // Return copy to prevent external mutation\n  }\n\n  /**\n   * Convert to plain object for serialization (e.g., to localStorage)\n   */\n  toJSON() {\n    return {\n      id: this._id,\n      title: this._title.value,\n      completed: this._completed,\n      createdAt: this._createdAt.toISOString(),\n      updatedAt: this._updatedAt.toISOString(),\n    };\n  }\n\n  /**\n   * Compare two Todo instances\n   */\n  equals(other: Todo): boolean {\n    return this._id === other._id && this._completed === other._completed;\n  }\n}\n","/**\n * Logger configuration for the application\n * Provides structured logging with consistent format\n */\n\ninterface LogEntry {\n  timestamp: string;\n  level: \"debug\" | \"info\" | \"warn\" | \"error\";\n  module?: string;\n  message: string;\n  data?: Record<string, unknown>;\n}\n\nclass Logger {\n  private logLevel: \"debug\" | \"info\" | \"warn\" | \"error\" = \"info\";\n\n  constructor(private moduleName?: string) {\n    // Only try to access import.meta in browser/vite environment\n    if (typeof window !== \"undefined\" && (window as any).import?.meta?.env?.VITE_LOG_LEVEL) {\n      this.logLevel = (window as any).import.meta.env.VITE_LOG_LEVEL;\n    }\n  }\n\n  private shouldLog(level: \"debug\" | \"info\" | \"warn\" | \"error\"): boolean {\n    const levels = [\"debug\", \"info\", \"warn\", \"error\"];\n    return levels.indexOf(level) >= levels.indexOf(this.logLevel);\n  }\n\n  private formatEntry(entry: LogEntry): string {\n    const { timestamp, level, module, message, data } = entry;\n    const moduleStr = module ? ` [${module}]` : \"\";\n    const dataStr = data ? ` ${JSON.stringify(data)}` : \"\";\n    return `${timestamp} ${level.toUpperCase()}${moduleStr}: ${message}${dataStr}`;\n  }\n\n  debug(message: string, data?: Record<string, unknown>): void {\n    if (this.shouldLog(\"debug\")) {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"debug\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.debug(this.formatEntry(entry));\n    }\n  }\n\n  info(message: string, data?: Record<string, unknown>): void {\n    if (this.shouldLog(\"info\")) {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"info\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.info(this.formatEntry(entry));\n    }\n  }\n\n  warn(message: string, data?: Record<string, unknown>): void {\n    if (this.shouldLog(\"warn\")) {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"warn\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.warn(this.formatEntry(entry));\n    }\n  }\n\n  error(message: string, error?: Error | Record<string, unknown>): void {\n    if (this.shouldLog(\"error\")) {\n      const data = error instanceof Error ? { message: error.message, stack: error.stack } : error;\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: \"error\",\n        module: this.moduleName,\n        message,\n        data,\n      };\n      console.error(this.formatEntry(entry));\n    }\n  }\n}\n\nexport const createLogger = (moduleName?: string): Logger => {\n  return new Logger(moduleName);\n};\n","/**\n * Shared type definitions for todo-copilot application\n * Used across all layers of the application\n */\n\n/**\n * Branded type for unique identifiers\n * Provides type-level distinction while maintaining string runtime behavior\n */\nexport type Branded<T, Brand> = T & { readonly __brand: Brand };\n\n/**\n * Factory for branded types\n */\nexport const brand = <T, B>(value: T): Branded<T, B> => value as Branded<T, B>;\n\n/**\n * Application error types\n */\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nexport class NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n}\n\nexport class QuotaExceededError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"QuotaExceededError\";\n  }\n}\n\nexport class StorageCorruptionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"StorageCorruptionError\";\n  }\n}\n\n/**\n * Base result type for operations\n */\nexport type Result<T, E = Error> = { type: \"success\"; value: T } | { type: \"error\"; error: E };\n\nexport const success = <T>(value: T): Result<T> => ({ type: \"success\", value });\nexport const failure = <E extends Error>(error: E): Result<never, E> => ({\n  type: \"error\",\n  error,\n});\n\n/**\n * Async result type\n */\nexport type AsyncResult<T, E = Error> = Promise<Result<T, E>>;\n","import { Todo, type TodoId } from \"../../domain/entities/Todo\";\nimport {\n    createTodoCompletedEvent,\n    createTodoCreatedEvent,\n    createTodoDeletedEvent,\n    type DomainEvent,\n} from \"../../domain/events/TodoEvents\";\nimport type { ITodoRepository } from \"../../domain/repositories/TodoRepository\";\nimport { createLogger } from \"../../infrastructure/config/logger\";\nimport { NotFoundError } from \"../../shared/types\";\nimport type {\n    CreateTodoCommand,\n    DeleteTodoCommand,\n    ToggleTodoCompletionCommand,\n} from \"../commands\";\nimport type { GetAllTodosQuery, GetAllTodosResponse, GetTodoByIdQuery } from \"../queries\";\n\n/**\n * Application service for Todo use cases\n * Orchestrates domain entities and repository interactions\n * Implements CQRS pattern with separate command and query methods\n */\nexport class TodoApplicationService {\n  private logger = createLogger(\"TodoApplicationService\");\n  private domainEvents: DomainEvent[] = [];\n\n  constructor(private todoRepository: ITodoRepository) {}\n\n  /**\n   * Create a new todo\n   * COMMAND: Changes application state\n   */\n  createTodo(command: CreateTodoCommand): Todo {\n    this.logger.debug(\"Creating todo\", { title: command.title });\n\n    const todo = Todo.create(command.title);\n    this.todoRepository.save(todo);\n\n    // Publish domain event\n    const event = createTodoCreatedEvent(todo.id, command.title, todo.createdAt);\n    this.domainEvents.push(event);\n    this.logger.info(\"Todo created\", { id: todo.id, title: command.title });\n\n    return todo;\n  }\n\n  /**\n   * Toggle todo completion status\n   * COMMAND: Changes application state\n   */\n  toggleTodoCompletion(command: ToggleTodoCompletionCommand): Todo {\n    this.logger.debug(\"Toggling todo completion\", { id: command.id });\n\n    const todo = this.todoRepository.findById(command.id as TodoId);\n    if (!todo) {\n      throw new NotFoundError(`Todo with id ${command.id} not found`);\n    }\n\n    const updatedTodo = todo.toggleCompletion();\n    this.todoRepository.save(updatedTodo);\n\n    // Publish domain event\n    const event = createTodoCompletedEvent(\n      updatedTodo.id,\n      updatedTodo.status,\n      updatedTodo.updatedAt\n    );\n    this.domainEvents.push(event);\n    this.logger.info(\"Todo toggled\", {\n      id: updatedTodo.id,\n      status: updatedTodo.status,\n    });\n\n    return updatedTodo;\n  }\n\n  /**\n   * Delete a todo\n   * COMMAND: Changes application state\n   */\n  deleteTodo(command: DeleteTodoCommand): void {\n    this.logger.debug(\"Deleting todo\", { id: command.id });\n\n    const todo = this.todoRepository.findById(command.id as TodoId);\n    if (!todo) {\n      throw new NotFoundError(`Todo with id ${command.id} not found`);\n    }\n\n    this.todoRepository.remove(command.id as TodoId);\n\n    // Publish domain event\n    const event = createTodoDeletedEvent(todo.id, new Date());\n    this.domainEvents.push(event);\n    this.logger.info(\"Todo deleted\", { id: command.id });\n  }\n\n  /**\n   * Get all todos\n   * QUERY: Read-only operation\n   */\n  getAllTodos(_query: GetAllTodosQuery): GetAllTodosResponse {\n    this.logger.debug(\"Fetching all todos\");\n    const todos = this.todoRepository.findAll();\n    this.logger.info(\"Retrieved todos\", { count: todos.length });\n    return {\n      todos,\n      count: todos.length,\n    };\n  }\n\n  /**\n   * Get a single todo by ID\n   * QUERY: Read-only operation\n   */\n  getTodoById(query: GetTodoByIdQuery): Todo | null {\n    this.logger.debug(\"Fetching todo\", { id: query.id });\n    const todo = this.todoRepository.findById(query.id as TodoId);\n    if (todo) {\n      this.logger.debug(\"Todo found\", { id: query.id });\n    } else {\n      this.logger.debug(\"Todo not found\", { id: query.id });\n    }\n    return todo;\n  }\n\n  /**\n   * Get domain events that occurred since last call\n   * Used for event sourcing and audit trails\n   */\n  getDomainEvents(): DomainEvent[] {\n    const events = [...this.domainEvents];\n    this.domainEvents = [];\n    return events;\n  }\n}\n","import type { TodoId, TodoStatus } from \"../entities/Todo\";\n\n/**\n * Domain events for Todo aggregate\n * Used for event sourcing and audit trails\n */\n\nexport interface DomainEvent {\n  aggregateId: TodoId;\n  aggregateType: \"Todo\";\n  eventType: string;\n  timestamp: Date;\n  data: Record<string, unknown>;\n}\n\n/**\n * Event fired when a new Todo is created\n */\nexport interface TodoCreatedEvent extends DomainEvent {\n  eventType: \"TodoCreated\";\n  data: {\n    title: string;\n    createdAt: string;\n  };\n}\n\nexport const createTodoCreatedEvent = (\n  id: TodoId,\n  title: string,\n  createdAt: Date\n): TodoCreatedEvent => ({\n  aggregateId: id,\n  aggregateType: \"Todo\",\n  eventType: \"TodoCreated\",\n  timestamp: new Date(),\n  data: {\n    title,\n    createdAt: createdAt.toISOString(),\n  },\n});\n\n/**\n * Event fired when a Todo's completion status changes\n */\nexport interface TodoCompletedEvent extends DomainEvent {\n  eventType: \"TodoCompleted\" | \"TodoUncompleted\";\n  data: {\n    status: TodoStatus;\n    changedAt: string;\n  };\n}\n\nexport const createTodoCompletedEvent = (\n  id: TodoId,\n  status: TodoStatus,\n  changedAt: Date\n): TodoCompletedEvent => ({\n  aggregateId: id,\n  aggregateType: \"Todo\",\n  eventType: status === \"Completed\" ? \"TodoCompleted\" : \"TodoUncompleted\",\n  timestamp: new Date(),\n  data: {\n    status,\n    changedAt: changedAt.toISOString(),\n  },\n});\n\n/**\n * Event fired when a Todo is deleted\n */\nexport interface TodoDeletedEvent extends DomainEvent {\n  eventType: \"TodoDeleted\";\n  data: {\n    deletedAt: string;\n  };\n}\n\nexport const createTodoDeletedEvent = (id: TodoId, deletedAt: Date): TodoDeletedEvent => ({\n  aggregateId: id,\n  aggregateType: \"Todo\",\n  eventType: \"TodoDeleted\",\n  timestamp: new Date(),\n  data: {\n    deletedAt: deletedAt.toISOString(),\n  },\n});\n","import { Todo, type TodoId } from \"../../domain/entities/Todo\";\nimport type { ITodoRepository } from \"../../domain/repositories/TodoRepository\";\nimport { NotFoundError, QuotaExceededError, StorageCorruptionError } from \"../../shared/types\";\n\n/**\n * LocalStorage implementation of TodoRepository\n * Persists todos to browser's localStorage\n *\n * Storage schema:\n * Key: \"todo_app:todos\"\n * Value: JSON array of serialized todos\n */\nexport class LocalStorageTodoRepository implements ITodoRepository {\n  private readonly storageKey = \"todo_app:todos\";\n  private readonly storagePrefix = \"todo_app:version\";\n  private readonly version = 1;\n\n  constructor(private readonly storage: Storage = window.localStorage) {\n    this.initializeStorage();\n  }\n\n  /**\n   * Initialize storage and verify integrity\n   */\n  private initializeStorage(): void {\n    try {\n      const versionKey = `${this.storagePrefix}`;\n      const storedVersion = this.storage.getItem(versionKey);\n\n      if (!storedVersion) {\n        this.storage.setItem(versionKey, this.version.toString());\n      } else if (Number.parseInt(storedVersion, 10) !== this.version) {\n        // Version mismatch - could implement migration logic here\n        console.warn(\"Storage version mismatch, resetting todos\");\n        this.clear();\n      }\n\n      // Try to parse existing todos to verify integrity\n      const data = this.storage.getItem(this.storageKey);\n      if (data) {\n        JSON.parse(data);\n      }\n    } catch (error) {\n      throw new StorageCorruptionError(\n        `Failed to initialize storage: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  findById(id: TodoId): Todo | null {\n    const todos = this.getAllFromStorage();\n    const todoData = todos.find((t) => t.id === id);\n    return todoData\n      ? Todo.fromPersistence(\n          todoData.id,\n          todoData.title,\n          todoData.completed,\n          todoData.createdAt,\n          todoData.updatedAt\n        )\n      : null;\n  }\n\n  findAll(): Todo[] {\n    const todos = this.getAllFromStorage();\n    return todos.map((t) =>\n      Todo.fromPersistence(t.id, t.title, t.completed, t.createdAt, t.updatedAt)\n    );\n  }\n\n  save(todo: Todo): void {\n    try {\n      const todos = this.getAllFromStorage();\n      const existingIndex = todos.findIndex((t) => t.id === todo.id);\n\n      if (existingIndex >= 0) {\n        todos[existingIndex] = todo.toJSON();\n      } else {\n        todos.push(todo.toJSON());\n      }\n\n      this.storage.setItem(this.storageKey, JSON.stringify(todos));\n    } catch (error) {\n      if (error instanceof DOMException && error.code === 22) {\n        throw new QuotaExceededError(\"localStorage quota exceeded. Please delete some todos.\");\n      }\n      throw error;\n    }\n  }\n\n  remove(id: TodoId): void {\n    const todos = this.getAllFromStorage();\n    const initialLength = todos.length;\n    const filtered = todos.filter((t) => t.id !== id);\n\n    if (filtered.length === initialLength) {\n      throw new NotFoundError(`Todo with id ${id} not found`);\n    }\n\n    this.storage.setItem(this.storageKey, JSON.stringify(filtered));\n  }\n\n  clear(): void {\n    this.storage.removeItem(this.storageKey);\n  }\n\n  count(): number {\n    return this.getAllFromStorage().length;\n  }\n\n  /**\n   * Get all todos from storage\n   * @private\n   */\n  private getAllFromStorage(): Array<{\n    id: string;\n    title: string;\n    completed: boolean;\n    createdAt: string;\n    updatedAt: string;\n  }> {\n    try {\n      const data = this.storage.getItem(this.storageKey);\n      if (!data) {\n        return [];\n      }\n      return JSON.parse(data);\n    } catch (error) {\n      throw new StorageCorruptionError(\n        `Failed to parse todos from storage: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n","/**\n * Shared types for Lambda API integration\n * Defines DTOs and response formats for the REST API\n */\n\nimport type { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from \"aws-lambda\";\n\n/**\n * Unified API response format for all Lambda endpoints\n * Ensures consistent response structure across all operations\n */\nexport interface ApiResponse<T = unknown> {\n  statusCode: number;\n  body: {\n    success: boolean;\n    data?: T;\n    error?: string;\n    message?: string;\n  };\n}\n\n/**\n * Todo data transfer object for API responses\n * Minimal serializable representation of Todo domain entity\n */\nexport interface TodoDTO {\n  id: string;\n  title: string;\n  completed: boolean;\n  createdAt: string; // ISO 8601 timestamp\n  updatedAt: string; // ISO 8601 timestamp\n}\n\n/**\n * Paginated list response for get todos endpoint\n */\nexport interface TodoListResponse {\n  items: TodoDTO[];\n  total: number;\n  page: number;\n  pageSize: number;\n  hasMore: boolean;\n}\n\n/**\n * Create todo request payload\n */\nexport interface CreateTodoRequest {\n  title: string;\n}\n\n/**\n * Update todo request payload\n */\nexport interface UpdateTodoRequest {\n  completed?: boolean;\n}\n\n/**\n * Lambda handler event type (alias for clarity)\n */\nexport type LambdaEvent = APIGatewayProxyEventV2;\n\n/**\n * Lambda handler context type\n */\nexport type LambdaContext = {\n  functionName: string;\n  functionVersion: string;\n  invokedFunctionArn: string;\n  memoryLimitInMB: string;\n  awsRequestId: string;\n  logGroupName: string;\n  logStreamName: string;\n  callbackWaitsForEmptyEventLoop?: boolean;\n};\n\n/**\n * Lambda handler return type\n */\nexport type LambdaResponse = APIGatewayProxyResultV2;\n\n/**\n * Utility function to extract path parameters from Lambda event\n */\nexport function getPathParameter(event: LambdaEvent, paramName: string): string | undefined {\n  return event.pathParameters?.[paramName];\n}\n\n/**\n * Utility function to extract query parameters from Lambda event\n */\nexport function getQueryParameter(event: LambdaEvent, paramName: string): string | undefined {\n  return event.queryStringParameters?.[paramName];\n}\n\n/**\n * Utility function to parse request body\n */\nexport function parseBody<T>(body: string | undefined): T {\n  if (!body) {\n    throw new Error(\"Request body is required\");\n  }\n  try {\n    return JSON.parse(body) as T;\n  } catch (error) {\n    throw new Error(`Failed to parse request body: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Create a successful API response\n */\nexport function createSuccessResponse<T>(statusCode: number, data: T): ApiResponse<T> {\n  return {\n    statusCode,\n    body: {\n      success: true,\n      data,\n    },\n  };\n}\n\n/**\n * Create an error API response\n */\nexport function createErrorResponse(statusCode: number, error: string, message?: string): ApiResponse {\n  return {\n    statusCode,\n    body: {\n      success: false,\n      error,\n      message,\n    },\n  };\n}\n","/**\n * Lambda handler for todo operations\n * Main entry point for AWS Lambda function handling HTTP requests from API Gateway\n */\n\nimport type { CreateTodoCommand } from \"../../../application/commands/CreateTodoCommand\";\nimport type { DeleteTodoCommand } from \"../../../application/commands/DeleteTodoCommand\";\nimport type { ToggleTodoCompletionCommand } from \"../../../application/commands/ToggleTodoCompletionCommand\";\nimport { TodoApplicationService } from \"../../../application/services/TodoApplicationService\";\nimport type { TodoId } from \"../../../domain/entities/Todo\";\nimport type { ITodoRepository } from \"../../../domain/repositories/TodoRepository\";\nimport { createLogger } from \"../../../infrastructure/config/logger\";\nimport { LocalStorageTodoRepository } from \"../../../infrastructure/persistence/LocalStorageTodoRepository\";\nimport type { CreateTodoRequest, LambdaContext, LambdaEvent, LambdaResponse, TodoDTO, UpdateTodoRequest } from \"../../../shared/api/types\";\nimport {\n    createErrorResponse,\n    createSuccessResponse,\n    getPathParameter,\n    getQueryParameter,\n    parseBody,\n} from \"../../../shared/api/types\";\n\nconst logger = createLogger(\"LambdaHandler\");\nlet todoRepository: ITodoRepository;\nlet applicationService: TodoApplicationService;\n\n/**\n * Initialize repository and application service\n * Called once per Lambda container (cold start)\n */\nfunction initializeHandlers(): void {\n  if (!todoRepository) {\n    todoRepository = new LocalStorageTodoRepository();\n    applicationService = new TodoApplicationService(todoRepository);\n  }\n}\n\n/**\n * Convert Todo domain entity to DTO for JSON response\n */\nfunction todoToDTO(todo: any): TodoDTO {\n  return {\n    id: todo.id,\n    title: todo.title.value || todo.title,\n    completed: todo.completed,\n    createdAt: todo.createdAt.toISOString?.() || todo.createdAt,\n    updatedAt: todo.updatedAt.toISOString?.() || todo.updatedAt,\n  };\n}\n\n/**\n * Handle GET /todos - Retrieve all todos\n */\nasync function handleGetTodos(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const page = parseInt(getQueryParameter(event, \"page\") || \"1\", 10);\n    const pageSize = parseInt(getQueryParameter(event, \"pageSize\") || \"50\", 10);\n\n    const result = applicationService.getAllTodos({});\n    const todos = result.todos;\n    const total = todos.length;\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedTodos = todos.slice(startIndex, endIndex);\n\n    const response = createSuccessResponse(200, {\n      items: paginatedTodos.map(todoToDTO),\n      total,\n      page,\n      pageSize,\n      hasMore: endIndex < total,\n    });\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error fetching todos\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle GET /todos/{id} - Retrieve a specific todo\n */\nasync function handleGetTodoById(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const id = getPathParameter(event, \"id\");\n    if (!id) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Todo ID is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const todo = applicationService.getTodoById({ id: id as any as TodoId });\n    if (!todo) {\n      const response = createErrorResponse(404, \"Not Found\", `Todo with ID ${id} not found`);\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = createSuccessResponse(200, todoToDTO(todo));\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error fetching todo\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle POST /todos - Create a new todo\n */\nasync function handleCreateTodo(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const payload = parseBody<CreateTodoRequest>(event.body);\n\n    if (!payload.title || payload.title.trim().length === 0) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Title is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    if (payload.title.length > 500) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Title cannot exceed 500 characters\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const command: CreateTodoCommand = {\n      title: payload.title,\n    };\n\n    const todo = applicationService.createTodo(command);\n    const response = createSuccessResponse(201, todoToDTO(todo));\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error creating todo\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle PUT /todos/{id} - Update a todo\n */\nasync function handleUpdateTodo(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const id = getPathParameter(event, \"id\");\n    if (!id) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Todo ID is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const payload = parseBody<UpdateTodoRequest>(event.body);\n\n    if (payload.completed === undefined) {\n      const response = createErrorResponse(400, \"Bad Request\", \"completed field is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const command: ToggleTodoCompletionCommand = {\n      id: id as any as TodoId,\n    };\n\n    const todo = applicationService.toggleTodoCompletion(command);\n    const response = createSuccessResponse(200, todoToDTO(todo));\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error updating todo\", error as any);\n\n    if (error instanceof Error && error.message.includes(\"not found\")) {\n      const response = createErrorResponse(404, \"Not Found\", \"Todo not found\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Handle DELETE /todos/{id} - Delete a todo\n */\nasync function handleDeleteTodo(event: LambdaEvent): Promise<LambdaResponse> {\n  try {\n    const id = getPathParameter(event, \"id\");\n    if (!id) {\n      const response = createErrorResponse(400, \"Bad Request\", \"Todo ID is required\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const command: DeleteTodoCommand = {\n      id: id as any as TodoId,\n    };\n\n    applicationService.deleteTodo(command);\n    const response = createSuccessResponse(204, null);\n\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify({ success: true }),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Error deleting todo\", error as any);\n\n    if (error instanceof Error && error.message.includes(\"not found\")) {\n      const response = createErrorResponse(404, \"Not Found\", \"Todo not found\");\n      return {\n        statusCode: response.statusCode,\n        body: JSON.stringify(response.body),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n\n/**\n * Main Lambda handler\n * Routes requests to appropriate handlers based on HTTP method and path\n */\nexport async function handler(event: LambdaEvent, context: LambdaContext): Promise<LambdaResponse> {\n  logger.info(\"Received Lambda event\", {\n    method: event.requestContext.http.method,\n    path: event.requestContext.http.path,\n    requestId: context.awsRequestId,\n  });\n\n  try {\n    initializeHandlers();\n\n    const method = event.requestContext.http.method;\n    const path = event.requestContext.http.path;\n\n    // Route requests to appropriate handlers\n    if (method === \"GET\" && path === \"/todos\") {\n      return await handleGetTodos(event);\n    }\n\n    if (method === \"GET\" && path.startsWith(\"/todos/\")) {\n      return await handleGetTodoById(event);\n    }\n\n    if (method === \"POST\" && path === \"/todos\") {\n      return await handleCreateTodo(event);\n    }\n\n    if (method === \"PUT\" && path.startsWith(\"/todos/\")) {\n      return await handleUpdateTodo(event);\n    }\n\n    if (method === \"DELETE\" && path.startsWith(\"/todos/\")) {\n      return await handleDeleteTodo(event);\n    }\n\n    // 404 for unknown routes\n    const response = createErrorResponse(404, \"Not Found\", \"Endpoint not found\");\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  } catch (error) {\n    logger.error(\"Unhandled error in Lambda handler\", error as any);\n    const response = createErrorResponse(\n      500,\n      \"Internal Server Error\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return {\n      statusCode: response.statusCode,\n      body: JSON.stringify(response.body),\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n  }\n}\n","/**\n * Lambda Entry Point\n * Main entry point for AWS Lambda function\n * Exports the handler function for use with AWS Lambda runtime\n * Can be bundled and deployed as Lambda function code\n */\n\nimport { handler } from \"./infrastructure/lambda/handlers/index\";\n\n/**\n * Export the Lambda handler\n * This function processes API Gateway events and returns formatted HTTP responses\n *\n * Usage:\n * - Deploy this file as Lambda function code\n * - Configure API Gateway to route requests to this function\n * - Handler name in Lambda console: index.handler\n */\nexport { handler };\n\n/**\n * For development/testing purposes, ensure the handler can be invoked directly\n */\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = { handler };\n}\n"],"names":["getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","TodoTitle","constructor","_value","this","trim","length","create","value","equals","other","Todo","_id","_title","_completed","_createdAt","_updatedAt","title","id","uuidv4","todoTitle","now","Date","fromPersistence","completed","createdAt","updatedAt","todoId","toggleCompletion","status","toJSON","toISOString","Logger","moduleName","window","import","meta","env","VITE_LOG_LEVEL","logLevel","shouldLog","level","levels","indexOf","formatEntry","entry","timestamp","module","message","data","moduleStr","dataStr","JSON","stringify","toUpperCase","debug","console","info","warn","error","stack","createLogger","NotFoundError","super","name","QuotaExceededError","StorageCorruptionError","TodoApplicationService","todoRepository","logger","domainEvents","createTodo","command","todo","save","event","aggregateId","aggregateType","eventType","toggleTodoCompletion","findById","updatedTodo","changedAt","deleteTodo","remove","deletedAt","getAllTodos","_query","todos","findAll","count","getTodoById","query","getDomainEvents","events","LocalStorageTodoRepository","storage","localStorage","initializeStorage","storageKey","storagePrefix","version","versionKey","storedVersion","getItem","Number","parseInt","clear","setItem","parse","String","todoData","getAllFromStorage","find","t","map","existingIndex","findIndex","DOMException","code","initialLength","filtered","filter","removeItem","getPathParameter","paramName","pathParameters","getQueryParameter","queryStringParameters","parseBody","body","createSuccessResponse","statusCode","success","createErrorResponse","applicationService","todoToDTO","async","handler","context","method","requestContext","http","path","requestId","awsRequestId","page","pageSize","total","startIndex","endIndex","response","items","hasMore","headers","handleGetTodos","startsWith","handleGetTodoById","payload","handleCreateTodo","includes","handleUpdateTodo","handleDeleteTodo","exports"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}