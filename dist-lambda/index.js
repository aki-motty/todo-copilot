"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});class t{constructor(t){this.moduleName=t,"undefined"!=typeof window&&window.import?.meta?.env?.VITE_LOG_LEVEL&&(this.logLevel=window.import.meta.env.VITE_LOG_LEVEL)}logLevel="info";shouldLog(t){const e=["debug","info","warn","error"];return e.indexOf(t)>=e.indexOf(this.logLevel)}formatEntry(t){const{timestamp:e,level:o,module:r,message:s,data:n}=t,i=r?` [${r}]`:"",d=n?` ${JSON.stringify(n)}`:"";return`${e} ${o.toUpperCase()}${i}: ${s}${d}`}debug(t,e){if(this.shouldLog("debug")){const o={timestamp:(new Date).toISOString(),level:"debug",module:this.moduleName,message:t,data:e};console.debug(this.formatEntry(o))}}info(t,e){if(this.shouldLog("info")){const o={timestamp:(new Date).toISOString(),level:"info",module:this.moduleName,message:t,data:e};console.info(this.formatEntry(o))}}warn(t,e){if(this.shouldLog("warn")){const o={timestamp:(new Date).toISOString(),level:"warn",module:this.moduleName,message:t,data:e};console.warn(this.formatEntry(o))}}error(t,e){if(this.shouldLog("error")){const o=e instanceof Error?{message:e.message,stack:e.stack}:e,r={timestamp:(new Date).toISOString(),level:"error",module:this.moduleName,message:t,data:o};console.error(this.formatEntry(r))}}}const e=e=>new t(e);let o;const r=new Uint8Array(16);function s(){if(!o&&(o="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!o))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(r)}const n=[];for(let I=0;I<256;++I)n.push((I+256).toString(16).slice(1));const i={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function d(t,e,o){if(i.randomUUID&&!t)return i.randomUUID();const r=(t=t||{}).random||(t.rng||s)();return r[6]=15&r[6]|64,r[8]=63&r[8]|128,function(t,e=0){return n[t[e+0]]+n[t[e+1]]+n[t[e+2]]+n[t[e+3]]+"-"+n[t[e+4]]+n[t[e+5]]+"-"+n[t[e+6]]+n[t[e+7]]+"-"+n[t[e+8]]+n[t[e+9]]+"-"+n[t[e+10]]+n[t[e+11]]+n[t[e+12]]+n[t[e+13]]+n[t[e+14]]+n[t[e+15]]}(r)}class a{constructor(t){if(this._value=t,!t||0===t.trim().length)throw new Error("Todo title cannot be empty");if(t.length>500)throw new Error("Todo title cannot exceed 500 characters")}static create(t){return new a(t.trim())}get value(){return this._value}equals(t){return this._value===t._value}toString(){return this._value}}class u{constructor(t,e,o,r,s){this._id=t,this._title=e,this._completed=o,this._createdAt=r,this._updatedAt=s}static create(t){const e=d(),o=a.create(t),r=new Date;return new u(e,o,!1,r,r)}static fromPersistence(t,e,o,r,s){const n=t,i=a.create(e);return new u(n,i,o,new Date(r),new Date(s))}toggleCompletion(){return new u(this._id,this._title,!this._completed,this._createdAt,new Date)}get id(){return this._id}get title(){return this._title}get completed(){return this._completed}get status(){return this._completed?"Completed":"Pending"}get createdAt(){return new Date(this._createdAt)}get updatedAt(){return new Date(this._updatedAt)}toJSON(){return{id:this._id,title:this._title.value,completed:this._completed,createdAt:this._createdAt.toISOString(),updatedAt:this._updatedAt.toISOString()}}equals(t){return this._id===t._id&&this._completed===t._completed}}class c extends Error{constructor(t){super(t),this.name="NotFoundError"}}class l extends Error{constructor(t){super(t),this.name="QuotaExceededError"}}class g extends Error{constructor(t){super(t),this.name="StorageCorruptionError"}}class p{constructor(t=window.localStorage){this.storage=t,this.initializeStorage()}storageKey="todo_app:todos";storagePrefix="todo_app:version";version=1;initializeStorage(){try{const t=`${this.storagePrefix}`,e=this.storage.getItem(t);e?Number.parseInt(e,10)!==this.version&&(console.warn("Storage version mismatch, resetting todos"),this.clear()):this.storage.setItem(t,this.version.toString());const o=this.storage.getItem(this.storageKey);o&&JSON.parse(o)}catch(t){throw new g(`Failed to initialize storage: ${t instanceof Error?t.message:String(t)}`)}}findById(t){const e=this.getAllFromStorage().find(e=>e.id===t);return e?u.fromPersistence(e.id,e.title,e.completed,e.createdAt,e.updatedAt):null}findAll(){return this.getAllFromStorage().map(t=>u.fromPersistence(t.id,t.title,t.completed,t.createdAt,t.updatedAt))}save(t){try{const e=this.getAllFromStorage(),o=e.findIndex(e=>e.id===t.id);o>=0?e[o]=t.toJSON():e.push(t.toJSON()),this.storage.setItem(this.storageKey,JSON.stringify(e))}catch(e){if(e instanceof DOMException&&22===e.code)throw new l("localStorage quota exceeded. Please delete some todos.");throw e}}remove(t){const e=this.getAllFromStorage(),o=e.length,r=e.filter(e=>e.id!==t);if(r.length===o)throw new c(`Todo with id ${t} not found`);this.storage.setItem(this.storageKey,JSON.stringify(r))}clear(){this.storage.removeItem(this.storageKey)}count(){return this.getAllFromStorage().length}getAllFromStorage(){try{const t=this.storage.getItem(this.storageKey);return t?JSON.parse(t):[]}catch(t){throw new g(`Failed to parse todos from storage: ${t instanceof Error?t.message:String(t)}`)}}}class h{constructor(t){this.todoRepository=t}logger=e("TodoApplicationService");domainEvents=[];createTodo(t){this.logger.debug("Creating todo",{title:t.title});const e=u.create(t.title);this.todoRepository.save(e);const o=(r=e.id,s=t.title,n=e.createdAt,{aggregateId:r,aggregateType:"Todo",eventType:"TodoCreated",timestamp:new Date,data:{title:s,createdAt:n.toISOString()}});var r,s,n;return this.domainEvents.push(o),this.logger.info("Todo created",{id:e.id,title:t.title}),e}toggleTodoCompletion(t){this.logger.debug("Toggling todo completion",{id:t.id});const e=this.todoRepository.findById(t.id);if(!e)throw new c(`Todo with id ${t.id} not found`);const o=e.toggleCompletion();this.todoRepository.save(o);const r=(s=o.id,n=o.status,i=o.updatedAt,{aggregateId:s,aggregateType:"Todo",eventType:"Completed"===n?"TodoCompleted":"TodoUncompleted",timestamp:new Date,data:{status:n,changedAt:i.toISOString()}});var s,n,i;return this.domainEvents.push(r),this.logger.info("Todo toggled",{id:o.id,status:o.status}),o}deleteTodo(t){this.logger.debug("Deleting todo",{id:t.id});const e=this.todoRepository.findById(t.id);if(!e)throw new c(`Todo with id ${t.id} not found`);this.todoRepository.remove(t.id);const o=(r=e.id,s=new Date,{aggregateId:r,aggregateType:"Todo",eventType:"TodoDeleted",timestamp:new Date,data:{deletedAt:s.toISOString()}});var r,s;this.domainEvents.push(o),this.logger.info("Todo deleted",{id:t.id})}getAllTodos(t){this.logger.debug("Fetching all todos");const e=this.todoRepository.findAll();return this.logger.info("Retrieved todos",{count:e.length}),{todos:e,count:e.length}}getTodoById(t){this.logger.debug("Fetching todo",{id:t.id});const e=this.todoRepository.findById(t.id);return e?this.logger.debug("Todo found",{id:t.id}):this.logger.debug("Todo not found",{id:t.id}),e}getDomainEvents(){const t=[...this.domainEvents];return this.domainEvents=[],t}}function y(t,e){return t.pathParameters?.[e]}function m(t,e){return t.queryStringParameters?.[e]}function f(t){if(!t)throw new Error("Request body is required");try{return JSON.parse(t)}catch(e){throw new Error(`Failed to parse request body: ${e instanceof Error?e.message:String(e)}`)}}function S(t,e){return{statusCode:t,body:{success:!0,data:e}}}function C(t,e,o){return{statusCode:t,body:{success:!1,error:e,message:o}}}const T=e("LambdaHandler");let b,w;function E(t){return{id:t.id,title:t.title.value||t.title,completed:t.completed,createdAt:t.createdAt.toISOString?.()||t.createdAt,updatedAt:t.updatedAt.toISOString?.()||t.updatedAt}}async function v(t,e){T.info("Received Lambda event",{method:t.requestContext.http.method,path:t.requestContext.http.path,requestId:e.awsRequestId});try{b||(b=new p,w=new h(b));const e=t.requestContext.http.method,o=t.requestContext.http.path;if("GET"===e&&"/todos"===o)return await async function(t){try{const e=parseInt(m(t,"page")||"1",10),o=parseInt(m(t,"pageSize")||"50",10),r=w.getAllTodos({}).todos,s=r.length,n=(e-1)*o,i=n+o,d=S(200,{items:r.slice(n,i).map(E),total:s,page:e,pageSize:o,hasMore:i<s});return{statusCode:d.statusCode,body:JSON.stringify(d.body),headers:{"Content-Type":"application/json"}}}catch(e){T.error("Error fetching todos",e);const t=C(500,"Internal Server Error",e instanceof Error?e.message:String(e));return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}}(t);if("GET"===e&&o.startsWith("/todos/"))return await async function(t){try{const e=y(t,"id");if(!e){const t=C(400,"Bad Request","Todo ID is required");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const o=w.getTodoById({id:e});if(!o){const t=C(404,"Not Found",`Todo with ID ${e} not found`);return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const r=S(200,E(o));return{statusCode:r.statusCode,body:JSON.stringify(r.body),headers:{"Content-Type":"application/json"}}}catch(e){T.error("Error fetching todo",e);const t=C(500,"Internal Server Error",e instanceof Error?e.message:String(e));return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}}(t);if("POST"===e&&"/todos"===o)return await async function(t){try{const e=f(t.body);if(!e.title||0===e.title.trim().length){const t=C(400,"Bad Request","Title is required");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}if(e.title.length>500){const t=C(400,"Bad Request","Title cannot exceed 500 characters");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const o={title:e.title},r=S(201,E(w.createTodo(o)));return{statusCode:r.statusCode,body:JSON.stringify(r.body),headers:{"Content-Type":"application/json"}}}catch(e){T.error("Error creating todo",e);const t=C(500,"Internal Server Error",e instanceof Error?e.message:String(e));return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}}(t);if("PUT"===e&&o.startsWith("/todos/"))return await async function(t){try{const e=y(t,"id");if(!e){const t=C(400,"Bad Request","Todo ID is required");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}if(void 0===f(t.body).completed){const t=C(400,"Bad Request","completed field is required");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const o={id:e},r=S(200,E(w.toggleTodoCompletion(o)));return{statusCode:r.statusCode,body:JSON.stringify(r.body),headers:{"Content-Type":"application/json"}}}catch(e){if(T.error("Error updating todo",e),e instanceof Error&&e.message.includes("not found")){const t=C(404,"Not Found","Todo not found");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const t=C(500,"Internal Server Error",e instanceof Error?e.message:String(e));return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}}(t);if("DELETE"===e&&o.startsWith("/todos/"))return await async function(t){try{const e=y(t,"id");if(!e){const t=C(400,"Bad Request","Todo ID is required");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const o={id:e};return w.deleteTodo(o),{statusCode:S(204,null).statusCode,body:JSON.stringify({success:!0}),headers:{"Content-Type":"application/json"}}}catch(e){if(T.error("Error deleting todo",e),e instanceof Error&&e.message.includes("not found")){const t=C(404,"Not Found","Todo not found");return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}const t=C(500,"Internal Server Error",e instanceof Error?e.message:String(e));return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}}(t);const r=C(404,"Not Found","Endpoint not found");return{statusCode:r.statusCode,body:JSON.stringify(r.body),headers:{"Content-Type":"application/json"}}}catch(o){T.error("Unhandled error in Lambda handler",o);const t=C(500,"Internal Server Error",o instanceof Error?o.message:String(o));return{statusCode:t.statusCode,body:JSON.stringify(t.body),headers:{"Content-Type":"application/json"}}}}"undefined"!=typeof module&&module.exports&&(module.exports={handler:v}),exports.handler=v;
//# sourceMappingURL=index.js.map
