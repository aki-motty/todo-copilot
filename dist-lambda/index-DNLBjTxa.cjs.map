{"version":3,"file":"index-DNLBjTxa.cjs","sources":["../node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                        break;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":["marshaller","serializer","deserializer","serdeContext","defaultContentType","constructor","this","serializeEventStream","eventStream","requestSchema","initialRequest","eventStreamMember","getEventStreamMember","unionSchema","getMemberSchema","initialRequestMarker","Symbol","eventStreamIterable","asyncIterator","headers","type","value","write","body","flush","page","serialize","event","unionMember","Object","keys","find","key","additionalHeaders","eventType","explicitPayloadContentType","writeEventBody","deserializeEventStream","response","responseSchema","initialResponseContainer","memberSchemas","getMemberSchemas","initialResponseMarker","asyncIterable","deserialize","async","dataObject","read","eventStreamSchema","isStructSchema","out","hasBindings","name","member","structIterator","eventHeader","eventPayload","getMergedTraits","Boolean","isBlobSchema","isStringSchema","utf8Encoder","toUtf8","isNumericSchema","BigInt","toString","Number","$unknown","firstEvent","next","done","Error","entries","explicitPayloadMember","getSchema","includes","eventSchema","memberName","memberSchema","isTimestampSchema","isBooleanSchema","payloadSchema","messageSerialization","utf8Decoder","fromUtf8"],"mappings":"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","x_google_ignoreList":[0]}